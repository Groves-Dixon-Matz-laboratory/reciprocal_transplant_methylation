head(k2o.r)
volcano_plot(k2o.r)
head(k2o.r)
dat= k2o.r
pcol='pvalue'
log2col='log2FoldChange'
fdrcol='padj'
cut=0.1
XLIM=NULL
plot(-log(dat[,pcol])~dat[,log2col], cex=0.5, mgp=c(2.1,1,0), xlab=expression(paste("Log"[2], 'Fold Difference')), ylab='-log(p-value)', axes=F, xlim=XLIM)
axis(1);axis(2, las=2);box()
sub=na.omit(dat)
sub2=sub[sub[,fdrcol]<cut,]
sub
sub=na.omit(dat)
sub
max(sub$padj)
is.na(dat$padj)
sum(is.na(dat$padj))
dat[is.na(dat$padj),]
sub=dat[!is.na(dat[,fdrcol])]
sub=dat[!is.na(dat[,fdrcol]),]
sub2=sub[sub[,fdrcol]<cut,]
points(-log(sub2[,pcol])~sub2[,log2col], pch=21,col="black",cex=0.6, bg='red')
head(o2k.r)
volcano_plot(o2k.r)
volcano_plot = function(dat, pcol='pvalue', log2col='log2FoldChange', fdrcol='padj', cut=0.1, XLIM=NULL){#
	plot(-log(dat[,pcol])~dat[,log2col], cex=0.5, mgp=c(2.1,1,0), xlab=expression(paste("Log"[2], 'Fold Difference')), ylab='-log(p-value)', axes=F, xlim=XLIM)#
	axis(1);axis(2, las=2);box()#
	sub=dat[!is.na(dat[,fdrcol]),]#
	sub2=sub[sub[,fdrcol]<cut,]#
	points(-log(sub2[,pcol])~sub2[,log2col], pch=21,col="black",cex=0.6, bg='red')#
}
volcano_plot(o2k.r)
CUT=0.01#
sig.genes1 = rownames(k2o.r)[abs(k2o.r$pvalue)<CUT];length(sig.genes1)#
sig.genes2 = rownames(o2k.r)[abs(o2k.r$pvalue)<CUT];length(sig.genes2)#
sig.genes = append(sig.genes1, sig.genes2)
sig.genes=unique(sig.genes)#
sig.genes=sig.genes[!is.na(sig.genes)]#
head(sig.genes)#
length(sig.genes)#
vsds=vsd[sig.genes,]#
coo=conditions#
#
dat=vsds#
head(dat)#
dim(dat) #720 genes most differe
ll=load("splitModels_GE.RData")
ll
head(home.r)
ll=load("GE_3mo.RData")
ll
head(vsd)
head(counts)
colnames(vsd) = colnames(counts)
head(k2o.r)#
head(o2k.r)#
#
#plot volcanos for the split models#
volcano_plot(k2o.r)#
volcano_plot(o2k.r)#
# rownames(k2o.r) = rownames(home.r)#
# rownames(o2k.r) = rownames(home.r)#
# CUT=2#
# top=1000#
# #for transplant among keppel corals#
# sig.genes = rownames(k2o.r)[abs(k2o.r$stat)>2.2];length(sig.genes)#
# sig.genes = tail(rownames(k2o.r[order(abs(k2o.r$stat)),]), n=top);length(sig.genes)#
#
# # #for transplant among orpheus corals#
# sig.genes = rownames(o2k.r)[abs(o2k.r$stat)>3.2];length(sig.genes)#
# sig.genes = tail(rownames(o2k.r[order(abs(o2k.r$stat)),]), n=top);length(sig.genes)#
#for both#
# sig.genes1 = rownames(k2o.r)[abs(k2o.r$stat)>CUT];length(sig.genes1)#
# sig.genes2 = rownames(o2k.r)[abs(o2k.r$stat)>CUT];length(sig.genes2)#
# sig.genes = append(sig.genes1, sig.genes2)#
CUT=0.01#
sig.genes1 = rownames(k2o.r)[abs(k2o.r$pvalue)<CUT];length(sig.genes1)#
sig.genes2 = rownames(o2k.r)[abs(o2k.r$pvalue)<CUT];length(sig.genes2)#
sig.genes = append(sig.genes1, sig.genes2)#
#to use top set significant genes:#
# sig.genes1 = tail(rownames(k2o.r[order(abs(k2o.r$stat)),]), n=top);length(sig.genes)#
# sig.genes2 = tail(rownames(o2k.r[order(abs(o2k.r$stat)),]), n=top);length(sig.genes)#
# sig.genes = append(sig.genes1, sig.genes2)#
# length(sig.genes)#
sig.genes=unique(sig.genes)#
sig.genes=sig.genes[!is.na(sig.genes)]#
head(sig.genes)#
length(sig.genes)#
vsds=vsd[sig.genes,]#
coo=conditions#
#
dat=vsds#
head(dat)#
dim(dat) #1326 genes most d
degs10<-rownames(dat)#
#
a.vsd<-dat[,c(grep("OO",colnames(dat)), grep("KK",colnames(dat)))] #transplant site effect on Orpheus corals#
a.vsd.supp<-dat[,c(grep("OK",colnames(dat)),grep("KO",colnames(dat)))] #transplant site effect on Keppel corals
#################Some genes have insufficient variance for DFA in data subsets!...find those genes using loop below#
dframe=(a.vsd[degs10,])#
for(col in rownames(dframe))#
	{  min=min(dframe[col,])#
		max=max(dframe[col,])#
		if(min == max){print(col)}#
		}#
#
#If print out above, copy gene names below and run line to remove genes from analysis. #
#degs9=degs10[! d
##############now use appropriate dataset for analysis#
#
pcp=prcomp(t(a.vsd[degs10,]), retx=TRUE, center=TRUE, scale.=TRUE) #scale.=TRUE#
scores=pcp$x#
screeplot(pcp,bstick=T) # only 1st PC is non-random when using diff exp genes only; higher PCs non-random when using all data...
clus=find.clusters(t(a.vsd[degs10,]),max.n.clus=15, n.clust=2, n.pca=4) #[degs10,]
#Use clus$grp to rename to in2in and off2off -#
#Host#
colnames(a.vsd) #
clus$grp=c(substr(colnames(a.vsd), start=1,stop=2)) #set the transplantation site as the groups#
# now lets build a discriminant function for these two groups:#
dp=dapc(t(a.vsd[degs10,]),clus$grp, n.da=1, perc.pca=80) #[de
quartz()#
scatter(dp,bg="white",scree.da=FALSE,legend=TRUE,solid=.4) #discriminant function for transplant
#APPLY FUNCTION TO OTHER SET OF SAMPLES#
pred.sup<-predict.dapc(dp,newdata=(t(a.vsd.supp[degs10,]))) #skip IO11C for host b/c outlier sample in WGCNA#
#
names(pred.sup)#
pred.sup$assign#
colnames(a.vsd.supp)#
#
#must create another dataframe structure in order to plot these predicted values#
test<-dp#
test$ind.coord<-pred.sup$ind.scores#
test$posterior<-pred.sup$posterior#
test$assign<-pred.sup$assign#
#HOST - for plotting distributions, must say which samples in which group#
test$grp<-as.factor(substr(colnames(a.vsd.supp), start =1, stop=2)) #make sure origin is same num as before: IN=2, OFF=1#
quartz()#
#
scatter(test,bg="white",scree.da=FALSE,legend=TRUE,solid=.4,ylim=c(0,0.6),xlim=c(-4,4)) #
#adjust axes to correspond to previous graph, then overlay plots in photoshop
############Build single plot with both#
library(ggplot2)#
t=pred.sup$ind.scores#
h=dp$ind.coord#
a=data.frame(rbind(t,h))#
head(a)#
a$treat=substr(rownames(a), start=1, stop=2)#
mns=tapply(a$LD1, a$treat, mean)#
#plot discriminant analysis#
color.set=c('blue', 'cyan', 'orange', 'red')#
quartz()#
ggplot(data=a, aes(LD1, fill=treat, color=treat)) + geom_density(alpha=0.4) + theme(panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black")) +scale_color_manual(values=color.set) + scale_fill_manual(values=color.set)  #+ geom_vline(xintercept=mns, color=color.set)
ggplot(data=a, aes(LD1, fill=treat, color=treat)) + geom_density(alpha=0.4) + theme(panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black")) +scale_color_manual(values=color.set) + scale_fill_manual(values=color.set)  #+ geom_vline(xintercept=mns, color=color.set)
#-------------------------------------------- Plot correlation with gain#
lda.res=a#
rownames(lda.res) = sub("_2m", "", rownames(lda.res))#
#--------gather the mbd discim data ------------#
lnames=load('bayRT_rlog_conditions_traits.RData')#
lda.res$Colony.ID = rownames(lda.res)#
head(lda.res)#
x = merge(traits, lda.res, by='Colony.ID', all.x=T)#
x=x[order(x$Colony.ID),]#
sum(x$Colony.ID == traits$Colony.ID)==nrow(traits)#
traits$mbd.LD1=x$LD1#
#--------------------------
head(traits)#
#plot correlation with gain#
CEX=2#
LWD=2#
plot(GAIN~mbd.LD1, data=traits)#
#KO samples#
d=traits[traits$ori=='K' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='cyan', pch=21, cex=CEX) #KO samples#
lmko=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmko, col = 'cyan', lty=2, lwd=LWD)#
summary(lmko)#
clip(-1e4,1e4,-1e4,1e4)#
#OK samples#
d=traits[traits$ori=='O' & traits$tra=='K' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='orange', pch=21, cex=CEX)  #OK samples#
lmok=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmok, col = 'orange', lty=2, lwd=LWD)#
summary(lmok)#
clip(-1e4,1e4,-1e4,1e4)#
#OO samples#
d=traits[traits$ori=='O' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='red', pch=21, cex=CEX)  #OO samples#
lmoo=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmoo, col = 'red', lty=2, lwd=LWD)#
summary(lmoo)#
clip(-1e4,1e4,-1e4,1e4)#
#KK samples#
d=traits[traits$ori=='K' & traits$tra=='K' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='blue', pch=21, cex=CEX)#
lmkk=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmkk, col = 'blue', lty=2, lwd=LWD)#
summary(lmkk)#
clip(-1e4,1e4,-1e4,1e4)#
legend('topright', c('KK', 'KO', 'OK', 'OO'), pt.bg=c('blue', 'cyan', 'orange', 'red'), pch=21)#
head(traits)
summary(lmkk)
head(traits)
traits$ge.LD1=x$LD1
#-------------------------------------------- Plot correlation with gain#
lda.res=a#
rownames(lda.res) = sub("_2m", "", rownames(lda.res))#
#--------gather the mbd discim data ------------#
lnames=load('bayRT_rlog_conditions_traits.RData')#
lda.res$Colony.ID = rownames(lda.res)#
head(lda.res)#
x = merge(traits, lda.res, by='Colony.ID', all.x=T)#
x=x[order(x$Colony.ID),]#
sum(x$Colony.ID == traits$Colony.ID)==nrow(traits)#
traits$ge.LD1=x$LD1#
#------------------
head(traits)
ge.traits=traits
save(ge.traits, file='ge.traits.Rdata')
rm(list=ls())
####################################### discriminant function analysis using adegenet package on rlog transformed expr data#
library(adegenet)#
#
##############################################upload the data#
setwd("~/Desktop/redo")#
ll=load("splitModels_MBD.RData")#
ll=load("mbd_3mo.RData")#
head(k2o.r)#
head(o2k.r)#
#
volcano_plot(k2o.r)#
volcano_plot(o2k.r)#
plot(-log(pvalue)~log2FoldChange, k2o.r,cex=0.5, mgp=c(2.1,1,0), xlab=expression(paste("Log"[2], 'Fold Difference')), ylab='-log(p-value)', axes=F)#
axis(1);axis(2, las=2);box()#
sub=na.omit(mg.orico)#
sub2=sub[sub$padj<0.1,]#
points(-log(pvalue)~log2FoldChange, data=sub2,pch=21,col="black",cex=0.6, bg='red')#
rownames(k2o.r) = rownames(home.r)#
rownames(o2k.r) = rownames(home.r)#
# CUT=2#
# top=1000#
# #for transplant among keppel corals#
# sig.genes = rownames(k2o.r)[abs(k2o.r$stat)>2.2];length(sig.genes)#
# sig.genes = tail(rownames(k2o.r[order(abs(k2o.r$stat)),]), n=top);length(sig.genes)#
#
# # #for transplant among orpheus corals#
# sig.genes = rownames(o2k.r)[abs(o2k.r$stat)>3.2];length(sig.genes)#
# sig.genes = tail(rownames(o2k.r[order(abs(o2k.r$stat)),]), n=top);length(sig.genes)#
#for both#
# sig.genes1 = rownames(k2o.r)[abs(k2o.r$stat)>CUT];length(sig.genes1)#
# sig.genes2 = rownames(o2k.r)[abs(o2k.r$stat)>CUT];length(sig.genes2)#
# sig.genes = append(sig.genes1, sig.genes2)#
CUT=0.01#
sig.genes1 = rownames(k2o.r)[abs(k2o.r$pvalue)<CUT];length(sig.genes1)#
sig.genes2 = rownames(o2k.r)[abs(o2k.r$pvalue)<CUT];length(sig.genes2)#
sig.genes = append(sig.genes1, sig.genes2)#
#to use top set significant genes:#
# sig.genes1 = tail(rownames(k2o.r[order(abs(k2o.r$stat)),]), n=top);length(sig.genes)#
# sig.genes2 = tail(rownames(o2k.r[order(abs(o2k.r$stat)),]), n=top);length(sig.genes)#
# sig.genes = append(sig.genes1, sig.genes2)#
# length(sig.genes)#
sig.genes=unique(sig.genes)#
sig.genes=sig.genes[!is.na(sig.genes)]#
head(sig.genes)#
length(sig.genes)#
vsds=vsd[sig.genes,]#
coo=conditions#
#
dat=vsds#
head(dat)#
dim(dat) #720 genes most differentially methylated by origin#
dat=dat[, !colnames(dat) %in% c('OO10_2m')]#
degs10<-rownames(dat)#
#
a.vsd<-dat[,c(grep("OO",colnames(dat)), grep("KK",colnames(dat)))] #transplant site effect on Orpheus corals#
a.vsd.supp<-dat[,c(grep("OK",colnames(dat)),grep("KO",colnames(dat)))] #transplant site effect on Keppel corals
ll=load("splitModels_MBD.RData")
head(k2o.r)
head(o2k.r)
########################################## discriminant function analysis using adegenet package on rlog transformed expr data#
library(adegenet)#
#
##############################################upload the data#
setwd("~/Desktop/redo")#
ll=load("splitModels_MBD.RData")#
ll=load("mbd_3mo.RData")#
head(k2o.r)#
head(o2k.r)#
#
#build volcano plots for split models#
volcano_plot(k2o.r)#
volcano_plot(o2k.r)#
#
#subset the dataset for genes that vary by transplantation (plastic genes)#
CUT=0.01#
sig.genes1 = rownames(k2o.r)[abs(k2o.r$pvalue)<CUT];length(sig.genes1)#
sig.genes2 = rownames(o2k.r)[abs(o2k.r$pvalue)<CUT];length(sig.genes2)#
sig.genes = unique(append(sig.genes1, sig.genes2))#
sig.genes=sig.genes[!is.na(sig.genes)]#
head(sig.genes)#
length(sig.genes)#
vsds=vsd[sig.genes,]#
coo=conditions#
dat=vsds#
head(dat)#
dim(dat) #720 genes
#remove sample OO10_2m#
dat=dat[, !colnames(dat) %in% c('OO10_2m')]#
degs10<-rownames(dat)#
#
a.vsd<-dat[,c(grep("OO",colnames(dat)), grep("KK",colnames(dat)))] #transplant site effect on Orpheus corals#
a.vsd.supp<-dat[,c(grep("OK",colnames(dat)),grep("KO",colnames(dat)))] #transplant
###############Some genes have insufficient variance for DFA in data subsets!...find those genes using loop below#
dframe=(a.vsd[degs10,])#
for(col in rownames(dframe))#
	{  min=min(dframe[col,])#
		max=max(dframe[col,])#
		if(min == max){print(col)}#
		}#
#
#If print out above, copy gene names below and run line to remove genes from analysis. #
#degs9=degs10[! degs10 %in% c("iso
#################now use appropriate dataset for analysis#
#
pcp=prcomp(t(a.vsd[degs10,]), retx=TRUE, center=TRUE, scale.=TRUE) #scale.=TRUE#
scores=pcp$x#
screeplot(pcp,bstick=T) # only 1st PC is non-random when using diff exp genes only; higher PCs non-random when using all data...#
#
# adegenet: finding clusters (even though we know what clusters we want) - choose 4 PCs and 2 groups#
clus=find.clusters(t(a.vsd[degs10,]),max.n.clus=15, n.clust=2, n.pca=4) #[degs10,]#
#Use clus$grp to rename to in2in and off2off -#
#Host#
colnames(a.vsd) #
clus$grp=c(substr(colnames(a.vsd), start=1,stop=2)) #set the transplantati
# now lets build a discriminant function for these two groups:#
dp=dapc(t(a.vsd[degs10,]),clus$grp, n.da=1, perc.pca=80) #[degs10,]#
# HOST: PCs: 6, functions: 1. For two groups only one discriminant function is possible.#
# SYM: PCs: 6, functions: 1.
quartz()#
scatter(dp,bg="white",scree.da=FALSE,legend=TRUE,solid=.4) #discriminant function for transplant
volcano_plot(k2o.r)
source("~/git_repositories/reciprocal_transplant_methylation/scripts/reciprocal_methylation_project_functions.R")
volcano_plot(k2o.r)
########################################## discriminant function analysis using adegenet package on rlog transformed expr data#
library(adegenet)#
source("~/git_repositories/reciprocal_transplant_methylation/scripts/reciprocal_methylation_project_functions.R")#
##############################################upload the data#
setwd("~/Desktop/redo")#
ll=load("splitModels_GE.RData")#
ll=load("GE_3mo.RData")#
colnames(vsd) = colnames(counts)#
head(k2o.r)#
head(o2k.r)#
#
#plot volcanos for the split models#
volcano_plot(k2o.r)
volcano_plot(o2k.r)
volcano_plot(k2o.r, XLIM=1.5)
volcano_plot(k2o.r, XLIM=c(-1.5, 1.5))
####################################### discriminant function analysis using adegenet package on rlog transformed expr data#
library(adegenet)#
source("~/git_repositories/reciprocal_transplant_methylation/scripts/reciprocal_methylation_project_functions.R")#
##############################################upload the data#
setwd("~/Desktop/redo")#
ll=load("splitModels_MBD.RData")#
ll=load("mbd_3mo.RData")#
head(k2o.r)#
head(o2k.r)#
#
#build volcano plots for split models#
volcano_plot(k2o.r, XLIM=c(-1.5, 1.5))
volcano_plot = function(dat, pcol='pvalue', log2col='log2FoldChange', fdrcol='padj', cut=0.1, XLIM=NULL, YLIM=NULL){#
	plot(-log(dat[,pcol])~dat[,log2col], cex=0.5, mgp=c(2.1,1,0), xlab=expression(paste("Log"[2], 'Fold Difference')), ylab='-log(p-value)', axes=F, xlim=XLIM, ylim=YLIM)#
	axis(1);axis(2, las=2);box()#
	sub=dat[!is.na(dat[,fdrcol]),]#
	sub2=sub[sub[,fdrcol]<cut,]#
	points(-log(sub2[,pcol])~sub2[,log2col], pch=21,col="black",cex=0.6, bg='red')#
}
######################################## discriminant function analysis using adegenet package on rlog transformed expr data#
library(adegenet)#
source("~/git_repositories/reciprocal_transplant_methylation/scripts/reciprocal_methylation_project_functions.R")#
##############################################upload the data#
setwd("~/Desktop/redo")#
ll=load("splitModels_GE.RData")#
ll=load("GE_3mo.RData")#
colnames(vsd) = colnames(counts)#
head(k2o.r)#
head(o2k.r)#
#
#plot volcanos for the split models#
volcano_plot(k2o.r, XLIM=c(-1.5, 1.5), YLIM=c(0,30))
volcano_plot(o2k.r, XLIM=c(-1.5, 1.5), YLIM=c(0,30))
########################################### discriminant function analysis using adegenet package on rlog transformed expr data#
library(adegenet)#
source("~/git_repositories/reciprocal_transplant_methylation/scripts/reciprocal_methylation_project_functions.R")#
##############################################upload the data#
setwd("~/Desktop/redo")#
ll=load("splitModels_MBD.RData")#
ll=load("mbd_3mo.RData")#
head(k2o.r)#
head(o2k.r)#
#
#build volcano plots for split models#
volcano_plot(k2o.r, XLIM=c(-1.5, 1.5), YLIM=c(0,30))
volcano_plot(o2k.r, XLIM=c(-1.5, 1.5), YLIM=c(0,30))
volcano_plot(k2o.r, XLIM=c(-1.5, 1.5), YLIM=c(0,30))
volcano_plot(o2k.r, XLIM=c(-1.5, 1.5), YLIM=c(0,30))
###################################### discriminant function analysis using adegenet package on rlog transformed expr data#
library(adegenet)#
source("~/git_repositories/reciprocal_transplant_methylation/scripts/reciprocal_methylation_project_functions.R")#
##############################################upload the data#
setwd("~/Desktop/redo")#
ll=load("splitModels_GE.RData")#
ll=load("GE_3mo.RData")#
colnames(vsd) = colnames(counts)#
head(k2o.r)#
head(o2k.r)#
#
#plot volcanos for the split models#
volcano_plot(k2o.r, XLIM=c(-1.5, 1.5), YLIM=c(0,30))#
volcano_plot(o2k.r, XLIM=c(-1.5, 1.5), YLIM=c(0,30))
volcano_plot(k2o.r, XLIM=c(-1.5, 1.5), YLIM=c(0,30), MAIN='k2o')
volcano_plot = function(dat, pcol='pvalue', log2col='log2FoldChange', fdrcol='padj', cut=0.1, XLIM=NULL, YLIM=NULL, MAIN=''){#
	plot(-log(dat[,pcol])~dat[,log2col], cex=0.5, mgp=c(2.1,1,0), xlab=expression(paste("Log"[2], 'Fold Difference')), ylab='-log(p-value)', axes=F, xlim=XLIM, ylim=YLIM, main=MAIN)#
	axis(1);axis(2, las=2);box()#
	sub=dat[!is.na(dat[,fdrcol]),]#
	sub2=sub[sub[,fdrcol]<cut,]#
	points(-log(sub2[,pcol])~sub2[,log2col], pch=21,col="black",cex=0.6, bg='red')#
}
volcano_plot(k2o.r, XLIM=c(-1.5, 1.5), YLIM=c(0,30), MAIN='k2o')
######### discriminant function analysis using adegenet package on rlog transformed expr data#
library(adegenet)#
source("~/git_repositories/reciprocal_transplant_methylation/scripts/reciprocal_methylation_project_functions.R")#
##############################################upload the data#
setwd("~/Desktop/redo")#
ll=load("splitModels_MBD.RData")#
ll=load("mbd_3mo.RData")#
head(k2o.r)#
head(o2k.r)#
#
#build volcano plots for split models#
volcano_plot(k2o.r, XLIM=c(-1.5, 1.5), YLIM=c(0,30), MAIN='k2o')#
volcano_plot(o2k.r, XLIM=c(-1.5, 1.5), YLIM=c(0,30), MAIN='o2k')
############################### discriminant function analysis using adegenet package on rlog transformed expr data#
library(adegenet)#
source("~/git_repositories/reciprocal_transplant_methylation/scripts/reciprocal_methylation_project_functions.R")#
##############################################upload the data#
setwd("~/Desktop/redo")#
ll=load("splitModels_GE.RData")#
ll=load("GE_3mo.RData")#
colnames(vsd) = colnames(counts)#
head(k2o.r)#
head(o2k.r)#
#
#plot volcanos for the split models#
volcano_plot(k2o.r, XLIM=c(-1.5, 1.5), YLIM=c(0,30), MAIN='k2o')#
volcano_plot(o2k.r, XLIM=c(-1.5, 1.5), YLIM=c(0,30), MAIN='o2k')
volcano_plot(o2k.r, XLIM=c(-1.5, 1.5), YLIM=c(0,29), MAIN='o2k')
############################### discriminant function analysis using adegenet package on rlog transformed expr data#
library(adegenet)#
source("~/git_repositories/reciprocal_transplant_methylation/scripts/reciprocal_methylation_project_functions.R")#
##############################################upload the data#
setwd("~/Desktop/redo")#
ll=load("splitModels_MBD.RData")#
ll=load("mbd_3mo.RData")#
head(k2o.r)#
head(o2k.r)#
#
#build volcano plots for split models#
volcano_plot(k2o.r, XLIM=c(-1.5, 1.5), YLIM=c(0,29), MAIN='k2o')#
volcano_plot(o2k.r, XLIM=c(-1.5, 1.5), YLIM=c(0,29), MAIN='o2k')
#################### discriminant function analysis using adegenet package on rlog transformed expr data#
library(adegenet)#
source("~/git_repositories/reciprocal_transplant_methylation/scripts/reciprocal_methylation_project_functions.R")#
##############################################upload the data#
setwd("~/Desktop/redo")#
ll=load("splitModels_GE.RData")#
ll=load("GE_3mo.RData")#
colnames(vsd) = colnames(counts)#
head(k2o.r)#
head(o2k.r)#
#
#plot volcanos for the split models#
volcano_plot(k2o.r, XLIM=c(-1.5, 1.5), YLIM=c(0,29), MAIN='k2o')#
volcano_plot(o2k.r, XLIM=c(-1.5, 1.5), YLIM=c(0,29), MAIN='o2k')
############################## discriminant function analysis using adegenet package on rlog transformed expr data#
library(adegenet)#
source("~/git_repositories/reciprocal_transplant_methylation/scripts/reciprocal_methylation_project_functions.R")#
##############################################upload the data#
setwd("~/Desktop/redo")#
ll=load("splitModels_MBD.RData")#
ll=load("mbd_3mo.RData")#
head(k2o.r)#
head(o2k.r)#
#
#build volcano plots for split models#
volcano_plot(k2o.r, XLIM=c(-1.5, 1.5), YLIM=c(0,29), MAIN='k2o')#
volcano_plot(o2k.r, XLIM=c(-1.5, 1.5), YLIM=c(0,29), MAIN='o2k')#
#
#subset the dataset for genes that vary by transplantation (plastic genes)#
CUT=0.01#
sig.genes1 = rownames(k2o.r)[abs(k2o.r$pvalue)<CUT];length(sig.genes1)#
sig.genes2 = rownames(o2k.r)[abs(o2k.r$pvalue)<CUT];length(sig.genes2)#
sig.genes = unique(append(sig.genes1, sig.genes2))#
sig.genes=sig.genes[!is.na(sig.genes)]#
head(sig.genes)#
length(sig.genes)#
vsds=vsd[sig.genes,]#
coo=conditions#
dat=vsds#
head(dat)#
dim(dat) #560 genes with gbM plasticity#
#
#remove sample OO10_2m#
dat=dat[, !colnames(dat) %in% c('OO10_2m')]#
degs10<-rownames(dat)#
#
a.vsd<-dat[,c(grep("OO",colnames(dat)), grep("KK",colnames(dat)))] #transplant site effect on Orpheus corals#
a.vsd.supp<-dat[,c(grep("OK",colnames(dat)),grep("KO",colnames(dat)))] #transplant site effect on Keppel corals#
#######################Some genes have insufficient variance for DFA in data subsets!...find those genes using loop below#
dframe=(a.vsd[degs10,])#
for(col in rownames(dframe))#
	{  min=min(dframe[col,])#
		max=max(dframe[col,])#
		if(min == max){print(col)}#
		}#
#
#If print out above, copy gene names below and run line to remove genes from analysis. #
#degs9=degs10[! degs10 %in% c("isogroup27486")]#
######################now use appropriate dataset for analysis#
#
pcp=prcomp(t(a.vsd[degs10,]), retx=TRUE, center=TRUE, scale.=TRUE) #scale.=TRUE#
scores=pcp$x#
screeplot(pcp,bstick=T) # only 1st PC is non-random when using diff exp genes only; higher PCs non-random when using all data...#
#
# adegenet: finding clusters (even though we know what clusters we want) - choose 4 PCs and 2 groups#
clus=find.clusters(t(a.vsd[degs10,]),max.n.clus=15, n.clust=2, n.pca=4) #[degs10,]#
#Use clus$grp to rename to in2in and off2off -#
#Host#
colnames(a.vsd) #
clus$grp=c(substr(colnames(a.vsd), start=1,stop=2)) #set the transplantation s
# now lets build a discriminant function for these two groups:#
dp=dapc(t(a.vsd[degs10,]),clus$grp, n.da=1, perc.pca=80) #[degs10,]#
# HOST: PCs: 6, functions: 1. For two groups only one discriminant function is possible.#
# SYM: PCs: 6, functions: 1.#
#
quartz()#
scatter(dp,bg="white",scree.da=FALSE,legend=TRUE,solid=.4) #discriminant function for transplant#
#APPLY FUNCTION TO OTHER SET OF SAMPLES#
pred.sup<-predict.dapc(dp,newdata=(t(a.vsd.supp[degs10,]))) #skip IO11C for host b/c outlier sample in WGCNA#
#
names(pred.sup)#
pred.sup$assign#
colnames(a.vsd.supp)#
#
#must create another dataframe structure in order to plot these predicted values#
test<-dp#
test$ind.coord<-pred.sup$ind.scores#
test$posterior<-pred.sup$posterior#
test$assign<-pred.sup$assign#
#HOST - for plotting distributions, must say which samples in which group#
test$grp<-as.factor(substr(colnames(a.vsd.supp), start =1, stop=2)) #make sure origin is same num as before: IN=2, OFF=1#
quartz()#
#
scatter(test,bg="white",scree.da=FALSE,legend=TRUE,solid=.4,ylim=c(0,0.6),xlim=c(-4,4)) #
#adjust axes to correspond to previous graph, then overlay plots in photoshop#
#####################Build single plot with both#
library(ggplot2)#
t=pred.sup$ind.scores#
h=dp$ind.coord#
a=data.frame(rbind(t,h))#
head(a)#
a$treat=substr(rownames(a), start=1, stop=2)#
mns=tapply(a$LD1, a$treat, mean)#
#plot discriminant analysis#
color.set=c('blue', 'cyan', 'orange', 'red')#
quartz()#
ggplot(data=a, aes(LD1, fill=treat, color=treat)) + geom_density(alpha=0.4) + theme(panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black")) +scale_color_manual(values=color.set) + scale_fill_manual(values=color.set)  #+ geom_vline(xintercept=mns, color=color.set)
ggplot(data=a, aes(LD1, fill=treat, color=treat)) + geom_density(alpha=0.4) + theme(panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black")) +scale_color_manual(values=color.set) + scale_fill_manual(values=color.set)  #+ geom_vline(xintercept=mns, color=color.set)
pred.sup<-predict.dapc(dp,newdata=(t(dat[degs10,]))) #skip IO11C for
names(pred.sup)#
pred.sup$assign#
colnames(a.vsd.supp)#
#
#must create another dataframe structure in order to plot these predicted values#
test<-dp#
test$ind.coord<-pred.sup$ind.scores#
test$posterior<-pred.sup$posterior#
test$assign<-pred.sup$assign#
#HOST - for plotting distributions, must say which samples in which group#
test$grp<-as.factor(substr(colnames(a.vsd.supp), start =1, stop=2)) #make sure origin is same num as before: IN=2, OFF=1#
quartz()#
#
scatter(test,bg="white",scree.da=FALSE,legend=TRUE,solid=.4,ylim=c(0,0.6),xlim=c(-4,4))
pred.sup<-predict.dapc(dp,newdata=(t(dat[degs10,]))) #skip IO11C for
pred.sup
a=data.frame(pred.sup$ind.cores)
a=data.frame(pred.sup$ind.scores)
a
a$grp=substr(rownames(a), start=1, stop=2)
scatter(a,bg="white",scree.da=FALSE,legend=TRUE,solid=.4,ylim=c(0,0.6),xlim=c(-4,4))
pred.sup<-predict.dapc(dp,newdata=(t(dat[degs10,]))) #skip IO11C for
scatter(pred.sup,bg="white",scree.da=FALSE,legend=TRUE,solid=.4,ylim=c(0,0.6),xlim=c(-4,4))
pred.sup<-predict.dapc(dp,newdata=(t(dat[degs10,]))) #skip IO11C for #
a=data.frame(pred.sup$ind.scores)#
a$grp=substr(rownames(a), start=1, stop=2)#
mns=tapply(a$LD1, a$treat, mean)
a$treat=substr(rownames(a), start=1, stop=2)
mns=tapply(a$LD1, a$treat, mean)
color.set=c('blue', 'cyan', 'orange', 'red')#
quartz()#
ggplot(data=a, aes(LD1, fill=treat, color=treat)) + geom_density(alpha=0.4) + theme(panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black")) +scale_color_manual(values=color.set) + scale_fill_manual(values=color.set)  #+ geom_vline(xintercept=mns, color=color.set)
ggplot(data=a, aes(LD1, fill=treat, color=treat)) + geom_density(alpha=0.5) + theme(panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black")) +scale_color_manual(values=color.set) + scale_fill_manual(values=color.set)  #+ geom_vline(xintercept=mns, color=color.set)
ggplot(data=a, aes(LD1, fill=treat, color=treat)) + geom_density(alpha=0.6) + theme(panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black")) +scale_color_manual(values=color.set) + scale_fill_manual(values=color.set)  #+ geom_vline(xintercept=mns, color=color.set)
ggplot(data=a, aes(LD1, fill=treat, color=treat)) + geom_density(alpha=0.75) + theme(panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black")) +scale_color_manual(values=color.set) + scale_fill_manual(values=color.set)  #+ geom_vline(xintercept=mns, color=color.set)
ggplot(data=a, aes(LD1, fill=treat, color=treat)) + geom_density(alpha=0.7) + theme(panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black")) +scale_color_manual(values=color.set) + scale_fill_manual(values=color.set)  #+ geom_vline(xintercept=mns, color=color.set)
ggplot(data=a, aes(LD1, fill=treat, color=treat)) + geom_density(alpha=0.6) + theme(panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black")) +scale_color_manual(values=color.set) + scale_fill_manual(values=color.set)  #+ geom_vline(xintercept=mns, color=color.set)
#-------------------------------------------- Plot correlation with gain#
lda.res=a#
rownames(lda.res) = sub("_2m", "", rownames(lda.res))#
#--------gather the mbd discim data ------------#
lnames=load('bayRT_rlog_conditions_traits.RData')#
lda.res$Colony.ID = rownames(lda.res)#
head(lda.res)#
x = merge(traits, lda.res, by='Colony.ID', all.x=T)#
x=x[order(x$Colony.ID),]#
sum(x$Colony.ID == traits$Colony.ID)==nrow(traits)#
traits$mbd.LD1=x$LD1#
#------------------------------------------------#
head(traits)#
#plot correlation with gain#
CEX=2#
LWD=2#
plot(GAIN~mbd.LD1, data=traits)#
#KO samples#
d=traits[traits$ori=='K' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='cyan', pch=21, cex=CEX) #KO samples#
lmko=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmko, col = 'cyan', lty=2, lwd=LWD)#
summary(lmko)#
clip(-1e4,1e4,-1e4,1e4)#
#OK samples#
d=traits[traits$ori=='O' & traits$tra=='K' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='orange', pch=21, cex=CEX)  #OK samples#
lmok=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmok, col = 'orange', lty=2, lwd=LWD)#
summary(lmok)#
clip(-1e4,1e4,-1e4,1e4)#
#OO samples#
d=traits[traits$ori=='O' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='red', pch=21, cex=CEX)  #OO samples#
lmoo=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmoo, col = 'red', lty=2, lwd=LWD)#
summary(lmoo)#
clip(-1e4,1e4,-1e4,1e4)#
#KK samples#
d=traits[traits$ori=='K' & traits$tra=='K' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='blue', pch=21, cex=CEX)#
lmkk=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmkk, col = 'blue', lty=2, lwd=LWD)#
summary(lmkk)#
clip(-1e4,1e4,-1e4,1e4)#
legend('topright', c('KK', 'KO', 'OK', 'OO'), pt.bg=c('blue', 'cyan', 'orange', 'red'), pch=21)#
head(traits)
head(traits)#
#plot correlation with gain#
CEX=2#
LWD=2#
plot(GAIN~mbd.LD1, data=traits)#
#KO samples#
d=traits[traits$ori=='K' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='cyan', pch=21, cex=CEX) #KO samples#
lmko=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmko, col = 'cyan', lty=2, lwd=LWD)#
summary(lmko)#
clip(-1e4,1e4,-1e4,1e4)#
#OK samples#
d=traits[traits$ori=='O' & traits$tra=='K' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='orange', pch=21, cex=CEX)  #OK samples#
lmok=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmok, col = 'orange', lty=2, lwd=LWD)#
summary(lmok)#
clip(-1e4,1e4,-1e4,1e4)#
#OO samples#
d=traits[traits$ori=='O' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='red', pch=21, cex=CEX)  #OO samples#
lmoo=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmoo, col = 'red', lty=2, lwd=LWD)#
summary(lmoo)#
clip(-1e4,1e4,-1e4,1e4)#
#KK samples#
d=traits[traits$ori=='K' & traits$tra=='K' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='blue', pch=21, cex=CEX)#
lmkk=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmkk, col = 'blue', lty=2, lwd=LWD)#
summary(lmkk)#
clip(-1e4,1e4,-1e4,1e4)#
legend('topright', c('KK', 'KO', 'OK', 'OO'), pt.bg=c('blue', 'cyan', 'orange', 'red'), pch=21)#
head(traits)
head(traits)#
#plot correlation with gain#
CEX=2#
LWD=2#
plot(GAIN~mbd.LD1, data=traits)#
#KO samples#
d=traits[traits$ori=='K' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='cyan', pch=21, cex=CEX) #KO samples#
lmko=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmko, col = 'cyan', lty=2, lwd=LWD)#
summary(lmko)#
clip(-1e4,1e4,-1e4,1e4)#
#OK samples#
d=traits[traits$ori=='O' & traits$tra=='K' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='orange', pch=21, cex=CEX)  #OK samples#
lmok=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmok, col = 'orange', lty=2, lwd=LWD)#
summary(lmok)#
clip(-1e4,1e4,-1e4,1e4)#
#OO samples
head(traits)
plot(GAIN~mbd.LD1, data=traits, col=paste(traits$ori, traits$tra))
plot(GAIN~mbd.LD1, data=traits)
#KO samples#
d=traits[traits$ori=='K' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='cyan', pch=21, cex=CEX) #KO samples#
lmko=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmko, col = 'cyan', lty=2, lwd=LWD)#
summary(lmko)#
clip(-1e4,1e4,-1e4,1e4)#
#OK samples#
d=traits[traits$ori=='O' & traits$tra=='K' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='orange', pch=21, cex=CEX)  #OK samples#
lmok=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmok, col = 'orange', lty=2, lwd=LWD)#
summary(lmok)#
clip(-1e4,1e4,-1e4,1e4)#
#OO samples#
d=traits[traits$ori=='O' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='red', pch=21, cex=CEX)  #OO samples#
lmoo=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmoo, col = 'red', lty=2, lwd=LWD)#
summary(lmoo)#
clip(-1e4,1e4,-1e4,1e4)#
#KK samples
head(traits)#
#plot correlation with gain#
CEX=2#
LWD=2#
plot(GAIN~mbd.LD1, data=traits)#
#KO samples#
d=traits[traits$ori=='K' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='cyan', pch=21, cex=CEX) #KO samples#
lmko=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmko, col = 'cyan', lty=2, lwd=LWD)#
summary(lmko)#
clip(-1e4,1e4,-1e4,1e4)#
#OK samples#
d=traits[traits$ori=='O' & traits$tra=='K' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='orange', pch=21, cex=CEX)  #OK samples#
lmok=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmok, col = 'orange', lty=2, lwd=LWD)#
summary(lmok)#
clip(-1e4,1e4,-1e4,1e4)#
#OO samples#
d=traits[traits$ori=='O' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
CEX=1#
points(GAIN~mbd.LD1, data=d, bg='red', pch=21, cex=CEX)  #OO samples#
lmoo=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmoo, col = 'red', lty=2, lwd=LWD)#
summary(lmoo)#
clip(-1e4,1e4,-1e4,1e4)#
#KK samples#
d=traits[traits$ori=='K' & traits$tra=='K' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='blue', pch=21, cex=CEX)#
lmkk=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmkk, col = 'blue', lty=2, lwd=LWD)#
summary(lmkk)#
clip(-1e4,1e4,-1e4,1e4)#
legend('topright', c('KK', 'KO', 'OK', 'OO'), pt.bg=c('blue', 'cyan', 'orange', 'red'), pch=21)#
head(traits)
plot(GAIN~mbd.LD1, data=traits)
head(traits)#
#plot correlation with gain#
LWD=2#
plot(GAIN~mbd.LD1, data=traits)#
#OO samples#
d=traits[traits$ori=='O' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
CEX=1#
points(GAIN~mbd.LD1, data=d, bg='red', pch=21, cex=CEX)  #OO samples#
lmoo=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmoo, col = 'red', lty=2, lwd=LWD)#
summary(lmoo)#
clip(-1e4,1e4,-1e4,1e4)#
#KK samples#
d=traits[traits$ori=='K' & traits$tra=='K' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='blue', pch=21, cex=CEX)#
lmkk=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmkk, col = 'blue', lty=2, lwd=LWD)#
summary(lmkk)#
clip(-1e4,1e4,-1e4,1e4)#
legend('topright', c('KK', 'KO', 'OK', 'OO'), pt.bg=c('blue', 'cyan', 'orange', 'red'), pch=21)#
head(traits)#
#KO samples#
CEX=2#
d=traits[traits$ori=='K' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='cyan', pch=21, cex=CEX) #KO samples#
lmko=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmko, col = 'cyan', lty=2, lwd=LWD)#
summary(lmko)#
clip(-1e4,1e4,-1e4,1e4)#
#OK samples#
d=traits[traits$ori=='O' & traits$tra=='K' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='orange', pch=21, cex=CEX)  #OK samples#
lmok=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmok, col = 'orange', lty=2, lwd=LWD)#
summary(lmok)#
clip(-1e4,1e4,-1e4,1e4)
color.set=c('blue', 'dodgerblue', 'orange', 'red')
quartz()#
ggplot(data=a, aes(LD1, fill=treat, color=treat)) + geom_density(alpha=0.6) + theme(panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black")) +scale_color_manual(values=color.set) + scale_fill_manual(values=color.set)  #+ geom_vline(xintercept=mns, color=color.set)
color.set=c('blue', 'teal', 'orange', 'red')
quartz()#
ggplot(data=a, aes(LD1, fill=treat, color=treat)) + geom_density(alpha=0.6) + theme(panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black")) +scale_color_manual(values=color.set) + scale_fill_manual(values=color.set)  #+ geom_vline(xintercept=mns, color=color.set)
color.set=c('blue', 'turquoise', 'orange', 'red')
quartz()#
ggplot(data=a, aes(LD1, fill=treat, color=treat)) + geom_density(alpha=0.6) + theme(panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black")) +scale_color_manual(values=color.set) + scale_fill_manual(values=color.set)  #+ geom_vline(xintercept=mns, color=color.set)
head(traits)#
#plot correlation with gain#
LWD=2#
plot(GAIN~mbd.LD1, data=traits)#
#OO samples#
d=traits[traits$ori=='O' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
CEX=1#
points(GAIN~mbd.LD1, data=d, bg='red', pch=21, cex=CEX)  #OO samples#
lmoo=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmoo, col = 'red', lty=2, lwd=LWD)#
summary(lmoo)#
clip(-1e4,1e4,-1e4,1e4)#
#KK samples#
d=traits[traits$ori=='K' & traits$tra=='K' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='blue', pch=21, cex=CEX)#
lmkk=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmkk, col = 'blue', lty=2, lwd=LWD)#
summary(lmkk)#
clip(-1e4,1e4,-1e4,1e4)#
legend('topright', c('KK', 'KO', 'OK', 'OO'), pt.bg=c('blue', 'cyan', 'orange', 'red'), pch=21)#
head(traits)#
#KO samples#
CEX=2#
d=traits[traits$ori=='K' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='cyan', pch=21, cex=CEX) #KO samples#
lmko=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmko, col = 'cyan', lty=2, lwd=LWD)#
summary(lmko)#
clip(-1e4,1e4,-1e4,1e4)#
#OK samples#
d=traits[traits$ori=='O' & traits$tra=='K' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='orange', pch=21, cex=CEX)  #OK samples#
lmok=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmok, col = 'orange', lty=2, lwd=LWD)#
summary(lmok)#
clip(-1e4,1e4,-1e4,1e4)
points(GAIN~mbd.LD1, data=d, bg=color.set[2], pch=21, cex=CEX) #KO samples
points(GAIN~mbd.LD1, data=d, bg=color.set[3], pch=21, cex=CEX) #KO samples
#KO samples#
CEX=2#
d=traits[traits$ori=='K' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg=color.set[2], pch=21, cex=CEX) #KO samples#
lmko=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmko, col = 'cyan', lty=2, lwd=LWD)#
summary(lmko)#
clip(-1e4,1e4,-1e4,1e4)#
#OK samples#
d=traits[traits$ori=='O' & traits$tra=='K' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg=color.set[3], pch=21, cex=CEX)  #OK samples#
lmok=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmok, col = 'orange', lty=2, lwd=LWD)#
summary(lmok)#
clip(-1e4,1e4,-1e4,1e4)
head(traits)#
#plot correlation with gain#
LWD=2#
plot(GAIN~mbd.LD1, data=traits)#
#OO samples#
d=traits[traits$ori=='O' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
CEX=1#
points(GAIN~mbd.LD1, data=d, bg='red', pch=21, cex=CEX)  #OO samples#
lmoo=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmoo, col = 'red', lty=2, lwd=LWD)#
summary(lmoo)#
clip(-1e4,1e4,-1e4,1e4)#
#KK samples#
d=traits[traits$ori=='K' & traits$tra=='K' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='blue', pch=21, cex=CEX)#
lmkk=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmkk, col = 'blue', lty=2, lwd=LWD)#
summary(lmkk)#
clip(-1e4,1e4,-1e4,1e4)#
legend('topright', c('KK', 'KO', 'OK', 'OO'), pt.bg=c('blue', 'cyan', 'orange', 'red'), pch=21)#
head(traits)#
#KO samples#
CEX=2#
d=traits[traits$ori=='K' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg=color.set[2], pch=21, cex=CEX) #KO samples#
lmko=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmko, col = color.set[2], lty=2, lwd=LWD)#
summary(lmko)#
clip(-1e4,1e4,-1e4,1e4)#
#OK samples#
d=traits[traits$ori=='O' & traits$tra=='K' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg=color.set[3], pch=21, cex=CEX)  #OK samples#
lmok=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmok, col = color.set[3], lty=2, lwd=LWD)#
summary(lmok)#
clip(-1e4,1e4,-1e4,1e4)
plot(GAIN~mbd.LD1, data=traits, ylab="Daily Weight Gain")
plot(GAIN~mbd.LD1, data=traits, ylab="Daily Weight Gain (%)")
plot(GAIN~mbd.LD1, data=traits, ylab="Daily Weight Gain (%)", xlab="gbM Discriminant Function")
#OO samples#
d=traits[traits$ori=='O' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
CEX=1#
points(GAIN~mbd.LD1, data=d, bg='red', pch=21, cex=CEX)  #OO samples#
lmoo=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmoo, col = 'red', lty=2, lwd=LWD)#
summary(lmoo)#
clip(-1e4,1e4,-1e4,1e4)#
#KK samples#
d=traits[traits$ori=='K' & traits$tra=='K' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='blue', pch=21, cex=CEX)#
lmkk=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmkk, col = 'blue', lty=2, lwd=LWD)#
summary(lmkk)#
clip(-1e4,1e4,-1e4,1e4)#
legend('topright', c('KK', 'KO', 'OK', 'OO'), pt.bg=c('blue', 'cyan', 'orange', 'red'), pch=21)#
head(traits)#
#KO samples#
CEX=2#
d=traits[traits$ori=='K' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg=color.set[2], pch=21, cex=CEX) #KO samples#
lmko=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmko, col = color.set[2], lty=2, lwd=LWD)#
summary(lmko)#
clip(-1e4,1e4,-1e4,1e4)#
#OK samples#
d=traits[traits$ori=='O' & traits$tra=='K' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg=color.set[3], pch=21, cex=CEX)  #OK samples#
lmok=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmok, col = color.set[3], lty=2, lwd=LWD)#
summary(lmok)#
clip(-1e4,1e4,-1e4,1e4)
plot(GAIN~mbd.LD1, data=traits, ylab="Daily Weight Gain (%)", xlab="gbM Discriminant Function", mpg=MPG)
MGP=c(2.1,1,0)#
volcano_plot = function(dat, pcol='pvalue', log2col='log2FoldChange', fdrcol='padj', cut=0.1, XLIM=NULL, YLIM=NULL, MAIN=''){#
	plot(-log(dat[,pcol])~dat[,log2col], cex=0.5, mgp=MPG, xlab=expression(paste("Log"[2], 'Fold Difference')), ylab='-log(p-value)', axes=F, xlim=XLIM, ylim=YLIM, main=MAIN)#
	axis(1);axis(2, las=2);box()#
	sub=dat[!is.na(dat[,fdrcol]),]#
	sub2=sub[sub[,fdrcol]<cut,]#
	points(-log(sub2[,pcol])~sub2[,log2col], pch=21,col="black",cex=0.6, bg='red')#
}
plot(GAIN~mbd.LD1, data=traits, ylab="Daily Weight Gain (%)", xlab="gbM Discriminant Function", mgp=MGP)
#OO samples#
d=traits[traits$ori=='O' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
CEX=1#
points(GAIN~mbd.LD1, data=d, bg='red', pch=21, cex=CEX)  #OO samples#
lmoo=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmoo, col = 'red', lty=2, lwd=LWD)#
summary(lmoo)#
clip(-1e4,1e4,-1e4,1e4)#
#KK samples#
d=traits[traits$ori=='K' & traits$tra=='K' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='blue', pch=21, cex=CEX)#
lmkk=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmkk, col = 'blue', lty=2, lwd=LWD)#
summary(lmkk)#
clip(-1e4,1e4,-1e4,1e4)#
legend('topright', c('KK', 'KO', 'OK', 'OO'), pt.bg=c('blue', 'cyan', 'orange', 'red'), pch=21)#
head(traits)#
#KO samples#
CEX=2#
d=traits[traits$ori=='K' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg=color.set[2], pch=21, cex=CEX) #KO samples#
lmko=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmko, col = color.set[2], lty=2, lwd=LWD)#
summary(lmko)#
clip(-1e4,1e4,-1e4,1e4)#
#OK samples#
d=traits[traits$ori=='O' & traits$tra=='K' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg=color.set[3], pch=21, cex=CEX)  #OK samples#
lmok=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmok, col = color.set[3], lty=2, lwd=LWD)#
summary(lmok)#
clip(-1e4,1e4,-1e4,1e4)
legend('topright', c('KK', 'KO', 'OK', 'OO'), pt.bg=color.set, pch=21)
ggplot(data=a, aes(LD1, fill=treat, color=treat)) + geom_density(alpha=0.6) + theme(panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black")) +scale_color_manual(values=color.set) + scale_fill_manual(values=color.set)  #+ geom_vline(xintercept=mns, color=color.set)
summary(lmko)
summary(lmok)
lnames=load("ge.traits.Rdata")
lnames
head(ge.traits)
head(traits)
traits$ge.LD1=ge.traits$ge.LD1
plot(traits$gbm.LD1~traits$ge.LD1)
plot(traits$mbd.LD1~traits$ge.LD1)
lm1=lm(traits$mbd.LD1~traits$ge.LD1)
summary(lm1)
abline(lm1)
traits$treatment=paste(traits$ori, traits$tra, sep='')
traits
colors=traits$treatment
colors[colors=='KK']<-color.set[1]
color.set
plot(traits$mbd.LD1~traits$ge.LD1, pch=21, bg=colors, col='black')
colors=traits$treatment#
colors[colors=='KK']<-color.set[1]#
colors[colors=='KO']<-color.set[2]#
colors[colors=='OK']<-color.set[3]#
colors[colors=='OO']<-color.set[4]#
#
plot(traits$mbd.LD1~traits$ge.LD1, pch=21, bg=colors, col='black')
plot(traits$mbd.LD1~traits$ge.LD1, pch=21, bg=colors, col='black')#
lm1=lm(traits$mbd.LD1~traits$ge.LD1)#
summary(lm1)#
abline(lm1)
####################################### discriminant function analysis using adegenet package on rlog transformed expr data#
library(adegenet)#
source("~/git_repositories/reciprocal_transplant_methylation/scripts/reciprocal_methylation_project_functions.R")#
##############################################upload the data#
setwd("~/Desktop/redo")#
ll=load("splitModels_GE.RData")#
ll=load("GE_3mo.RData")#
colnames(vsd) = colnames(counts)#
head(k2o.r)#
head(o2k.r)#
#
#plot volcanos for the split models#
volcano_plot(k2o.r, XLIM=c(-1.5, 1.5), YLIM=c(0,29), MAIN='k2o')#
volcano_plot(o2k.r, XLIM=c(-1.5, 1.5), YLIM=c(0,29), MAIN='o2k')#
# rownames(k2o.r) = rownames(home.r)#
# rownames(o2k.r) = rownames(home.r)#
# CUT=2#
# top=1000#
# #for transplant among keppel corals#
# sig.genes = rownames(k2o.r)[abs(k2o.r$stat)>2.2];length(sig.genes)#
# sig.genes = tail(rownames(k2o.r[order(abs(k2o.r$stat)),]), n=top);length(sig.genes)#
#
# # #for transplant among orpheus corals#
# sig.genes = rownames(o2k.r)[abs(o2k.r$stat)>3.2];length(sig.genes)#
# sig.genes = tail(rownames(o2k.r[order(abs(o2k.r$stat)),]), n=top);length(sig.genes)#
#for both#
# sig.genes1 = rownames(k2o.r)[abs(k2o.r$stat)>CUT];length(sig.genes1)#
# sig.genes2 = rownames(o2k.r)[abs(o2k.r$stat)>CUT];length(sig.genes2)#
# sig.genes = append(sig.genes1, sig.genes2)#
CUT=0.01#
sig.genes1 = rownames(k2o.r)[abs(k2o.r$pvalue)<CUT];length(sig.genes1)#
sig.genes2 = rownames(o2k.r)[abs(o2k.r$pvalue)<CUT];length(sig.genes2)#
sig.genes = append(sig.genes1, sig.genes2)#
#to use top set significant genes:#
# sig.genes1 = tail(rownames(k2o.r[order(abs(k2o.r$stat)),]), n=top);length(sig.genes)#
# sig.genes2 = tail(rownames(o2k.r[order(abs(o2k.r$stat)),]), n=top);length(sig.genes)#
# sig.genes = append(sig.genes1, sig.genes2)#
# length(sig.genes)#
sig.genes=unique(sig.genes)#
sig.genes=sig.genes[!is.na(sig.genes)]#
head(sig.genes)#
length(sig.genes)#
vsds=vsd[sig.genes,]#
coo=conditions#
#
dat=vsds#
head(dat)#
dim(dat) #1326 genes most differentially methylated by origin#
# dat=dat[, !colnames(dat) %in% c('OO10_2m')]#
degs10<-rownames(dat)#
#
a.vsd<-dat[,c(grep("OO",colnames(dat)), grep("KK",colnames(dat)))] #transplant site effect on Orpheus corals#
a.vsd.supp<-dat[,c(grep("OK",colnames(dat)),grep("KO",colnames(dat)))] #transplant site effect on Keppel corals#
#######################Some genes have insufficient variance for DFA in data subsets!...find those genes using loop below#
dframe=(a.vsd[degs10,])#
for(col in rownames(dframe))#
	{  min=min(dframe[col,])#
		max=max(dframe[col,])#
		if(min == max){print(col)}#
		}#
#
#If print out above, copy gene names below and run line to remove genes from analysis. #
#degs9=degs10[! degs10 %in% c("isogroup27486")]#
######################now use appropriate dataset for analysis#
#
pcp=prcomp(t(a.vsd[degs10,]), retx=TRUE, center=TRUE, scale.=TRUE) #scale.=TRUE#
scores=pcp$x#
screeplot(pcp,bstick=T) # only 1st PC is non-random when using diff exp genes only; higher PCs non-random when using all data...#
#
# adegenet: finding clusters (even though we know what clusters we want) - choose 4 PCs and 2 groups#
clus=find.clusters(t(a.vsd[degs10,]),max.n.clus=15, n.clust=2, n.pca=4) #[degs10,]#
#Use clus$grp to rename to in2in and off2off -#
#Host#
colnames(a.vsd) #
clus$grp=c(substr(colnames(a.vsd), start=1,stop=2)) #set the transplantation site as the groups#
# now lets build a discriminant function for these two groups:#
dp=dapc(t(a.vsd[degs10,]),clus$grp, n.da=1, perc.pca=80) #[degs10,]#
# HOST: PCs: 6, functions: 1. For two groups only one discriminant function is possible.#
# SYM: PCs: 6, functions: 1.#
#
quartz()#
scatter(dp,bg="white",scree.da=FALSE,legend=TRUE,solid=.4) #discriminant function for transplant#
#APPLY FUNCTION TO OTHER SET OF SAMPLES#
pred.sup<-predict.dapc(dp,newdata=(t(a.vsd.supp[degs10,]))) #skip IO11C for host b/c outlier sample in WGCNA#
#
names(pred.sup)#
pred.sup$assign#
colnames(a.vsd.supp)#
#
#must create another dataframe structure in order to plot these predicted values#
test<-dp#
test$ind.coord<-pred.sup$ind.scores#
test$posterior<-pred.sup$posterior#
test$assign<-pred.sup$assign#
#HOST - for plotting distributions, must say which samples in which group#
test$grp<-as.factor(substr(colnames(a.vsd.supp), start =1, stop=2)) #make sure origin is same num as before: IN=2, OFF=1#
quartz()#
#
scatter(test,bg="white",scree.da=FALSE,legend=TRUE,solid=.4,ylim=c(0,0.6),xlim=c(-4,4)) #
#adjust axes to correspond to previous graph, then overlay plots in photoshop#
#####################Build single plot with both#
library(ggplot2)#
t=pred.sup$ind.scores#
h=dp$ind.coord#
a=data.frame(rbind(t,h))#
head(a)#
a$treat=substr(rownames(a), start=1, stop=2)#
mns=tapply(a$LD1, a$treat, mean)#
#plot discriminant analysis#
color.set=c('blue', 'cyan', 'orange', 'red')#
quartz()#
ggplot(data=a, aes(LD1, fill=treat, color=treat)) + geom_density(alpha=0.4) + theme(panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black")) +scale_color_manual(values=color.set) + scale_fill_manual(values=color.set)  #+ geom_vline(xintercept=mns, color=color.set)
color.set=c('blue', 'turquoise', 'orange', 'red')
ggplot(data=a, aes(LD1, fill=treat, color=treat)) + geom_density(alpha=0.4) + theme(panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black")) +scale_color_manual(values=color.set) + scale_fill_manual(values=color.set)  #+ geom_vline(xintercept=mns, color=color.set)
ggplot(data=a, aes(LD1, fill=treat, color=treat)) + geom_density(alpha=0.6) + theme(panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black")) +scale_color_manual(values=color.set) + scale_fill_manual(values=color.set)  #+ geom_vline(xintercept=mns, color=color.set)
#-------------------------------------------- Plot correlation with gain#
lda.res=a#
rownames(lda.res) = sub("_2m", "", rownames(lda.res))#
#--------gather the mbd discim data ------------#
lnames=load('bayRT_rlog_conditions_traits.RData')#
lda.res$Colony.ID = rownames(lda.res)#
head(lda.res)#
x = merge(traits, lda.res, by='Colony.ID', all.x=T)#
x=x[order(x$Colony.ID),]#
sum(x$Colony.ID == traits$Colony.ID)==nrow(traits)#
traits$mbd.LD1=x$LD1#
#------------------------------------------------#
head(traits)#
#plot correlation with gain#
LWD=2#
plot(GAIN~mbd.LD1, data=traits, ylab="Daily Weight Gain (%)", xlab="gbM Discriminant Function", mgp=MGP)#
#OO samples#
d=traits[traits$ori=='O' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
CEX=1#
points(GAIN~mbd.LD1, data=d, bg='red', pch=21, cex=CEX)  #OO samples#
lmoo=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmoo, col = 'red', lty=2, lwd=LWD)#
summary(lmoo)#
clip(-1e4,1e4,-1e4,1e4)#
#KK samples#
d=traits[traits$ori=='K' & traits$tra=='K' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='blue', pch=21, cex=CEX)#
lmkk=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmkk, col = 'blue', lty=2, lwd=LWD)#
summary(lmkk)#
clip(-1e4,1e4,-1e4,1e4)#
legend('topright', c('KK', 'KO', 'OK', 'OO'), pt.bg=color.set, pch=21)#
head(traits)#
#KO samples#
CEX=2#
d=traits[traits$ori=='K' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg=color.set[2], pch=21, cex=CEX) #KO samples#
lmko=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmko, col = color.set[2], lty=2, lwd=LWD)#
summary(lmko)#
clip(-1e4,1e4,-1e4,1e4)#
#OK samples#
d=traits[traits$ori=='O' & traits$tra=='K' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg=color.set[3], pch=21, cex=CEX)  #OK samples#
lmok=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmok, col = color.set[3], lty=2, lwd=LWD)#
summary(lmok)#
clip(-1e4,1e4,-1e4,1e4)
head(traits)#
#plot correlation with gain#
LWD=2#
plot(GAIN~mbd.LD1, data=traits, ylab="Daily Weight Gain (%)", xlab="gbM Discriminant Function", mgp=MGP)#
#OO samples#
d=traits[traits$ori=='O' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
CEX=1#
points(GAIN~mbd.LD1, data=d, bg='red', pch=21, cex=CEX)  #OO samples#
lmoo=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmoo, col = 'red', lty=2, lwd=LWD)#
summary(lmoo)#
clip(-1e4,1e4,-1e4,1e4)#
#KK samples#
d=traits[traits$ori=='K' & traits$tra=='K' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg='blue', pch=21, cex=CEX)#
lmkk=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmkk, col = 'blue', lty=2, lwd=LWD)#
summary(lmkk)#
clip(-1e4,1e4,-1e4,1e4)#
legend('topright', c('KK', 'KO', 'OK', 'OO'), pt.bg=color.set, pch=21)#
head(traits)#
#KO samples#
CEX=2#
d=traits[traits$ori=='K' & traits$tra=='O' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg=color.set[2], pch=21, cex=CEX) #KO samples#
lmko=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmko, col = color.set[2], lty=2, lwd=LWD)#
summary(lmko)#
clip(-1e4,1e4,-1e4,1e4)#
#OK samples#
d=traits[traits$ori=='O' & traits$tra=='K' & !is.na(traits$mbd.LD1) & !is.na(traits$GAIN),]#
points(GAIN~mbd.LD1, data=d, bg=color.set[3], pch=21, cex=CEX)  #OK samples#
lmok=lm(GAIN~mbd.LD1, data=d)#
clip(x1=min(na.omit(d$mbd.LD1)), max(d$mbd.LD1), 0, 100)#
abline(lmok, col = color.set[3], lty=2, lwd=LWD)#
summary(lmok)#
clip(-1e4,1e4,-1e4,1e4)
head(traits)
traits$geno=paste(traits$ori, traits$num)
traits$geno=paste(traits$ori, traits$num, sep='')
head(traits)
genos=unique(traits$geno)
gsub=traits[traits$geno==g,]
g='K1'
gsub=traits[traits$geno==g,]
gsub
ll
head(vsd)
dim(vsd)
dim(dds)
head(dds)
x=data.frame(rownames(vsd), 0)
load("~/git_Repositories/reciprocal_transplant_methylation/datasets/ProteinTable.Rdata")
lnames=load("~/git_Repositories/reciprocal_transplant_methylation/datasets/ProteinTable.Rdata")
lnames
head(ptable)
colnames(x) = c('locusName', )
colnames(x) = c('locusName', 'sig')
head(x)
x$sig[x$locusName %in% sig.genes]<-1
head(x)
sum(x$sig) == length(sig.genes)
#protein_table.R#
setwd("~/git_Repositories/reciprocal_transplant_methylation/")#
ptable = read.table("datasets/ProteinTable10529_263537.txt", header = F, sep = "\t", quote = "")#note this file can be downloaded from here: https://www.ncbi.nlm.nih.gov/genome/proteins/10529?genome_assembly_id=263537#
head(ptable)#
ptable = ptable[,c(2,7,8,10)]#
colnames(ptable) = c('contig', 'locusName', 'genbank.prot', 'protein.name')#
head(ptable)
ptable=ptable[!duplicated(ptable$locusName),]
setwd("~/git_Repositories/reciprocal_transplant_methylation/")
save(ptable, file='datasets/ProteinTable.Rdata')
#output for GO enrichment#
lnames=load("~/git_Repositories/reciprocal_transplant_methylation/datasets/ProteinTable.Rdata")#
head(ptable)
y=merge(x,ptable, by='locusName')
y=merge(x,ptable, by='locusName', all.x=T, all.y=F)
dim(y)
dim(x)
head(y)
out=data.frame(y$genbank.prot, y$sig)
head(out)
colnames(out) = c('prot', 'sig')
head(na.omit(out))
out=na.omit(data.frame(y$genbank.prot, y$sig))
colnames(out) = c('prot', 'sig')#
head(out)
write.csv(out, file='~/git_Repositories/reciprocal_transplant_methylation/go_mwu')
write.csv(out, file='~/git_Repositories/reciprocal_transplant_methylation/go_mwu/plastic_meth_genes.csv')
######################################################
# First, press command-D on mac or ctrl-shift-H in Rstudio and navigate to the directory containing scripts and input files. Then edit, mark and execute the following bits of code, one after another.#
setwd("~/git_Repositories/reciprocal_transplant_methylation/go_mwu")#
#
# Edit these to match your data file names: #
input="plastic_meth_genes.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).#
goAnnotations="adig_go_final.tsv" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.#
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml#
goDivision="MF" # either MF, or BP, or CC#
source("gomwu.functions.R")
# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.#
gomwuStats(input, goDatabase, goAnnotations, goDivision,#
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already#
	largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes#
	smallest=5,   # a GO category should contain at least this many genes to be considered#
	clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.#
	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. #
#	Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)#
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module #
)#
# do not contin
write.csv(out, file='~/git_Repositories/reciprocal_transplant_methylation/go_mwu/plastic_meth_genes.csv', rownames=F, quote=F)
write.csv(out, file='~/git_Repositories/reciprocal_transplant_methylation/go_mwu/plastic_meth_genes.csv', row.names=F, quote=F)
# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.#
gomwuStats(input, goDatabase, goAnnotations, goDivision,#
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already#
	largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes#
	smallest=5,   # a GO category should contain at least this many genes to be considered#
	clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.#
	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. #
#	Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)#
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module #
)#
# do not contin
goDivision="CC" # either MF, or BP, or CC
# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.#
gomwuStats(input, goDatabase, goAnnotations, goDivision,#
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already#
	largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes#
	smallest=5,   # a GO category should contain at least this many genes to be considered#
	clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.#
	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. #
#	Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)#
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module #
)#
# do not c
# Plotting results#
quartz()#
gomwuPlot(input,goAnnotations,goDivision,#
	absValue=0.001,  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").#
	level1=0.2, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.05, # FDR cutoff to print in regular (not italic) font.#
	level3=0.01, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)#
# manually rescale the plot so the tree matches the text #
# if there are to
goDivision="BP" # either MF, or BP, or CC
# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.#
gomwuStats(input, goDatabase, goAnnotations, goDivision,#
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already#
	largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes#
	smallest=5,   # a GO category should contain at least this many genes to be considered#
	clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.#
	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. #
#	Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)#
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module #
)#
# do not continue if the printout shows that no GO terms pass 10% FDR.#
# Plotting results#
quartz()#
gomwuPlot(input,goAnnotations,goDivision,#
	absValue=0.001,  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").#
	level1=0.2, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.05, # FDR cutoff to print in regular (not italic) font.#
	level3=0.01, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)#
# manually rescale the plot so the tree matches the text #
# if there are too many cat
###########################################################
# First, press command-D on mac or ctrl-shift-H in Rstudio and navigate to the directory containing scripts and input files. Then edit, mark and execute the following bits of code, one after another.#
setwd("~/git_Repositories/reciprocal_transplant_methylation/go_mwu")#
#
# Edit these to match your data file names: #
input="origin_gbm_go_mwu_input.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).#
goAnnotations="adig_go_final.tsv" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.#
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml#
goDivision="CC" # either MF, or BP, or CC#
source("gomwu.functions.R")
# Plotting results#
quartz()#
gomwuPlot(input,goAnnotations,goDivision,#
	absValue=-log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").#
	level1=0.1, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.05, # FDR cutoff to print in regular (not italic) font.#
	level3=0.01, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)#
# manually rescale the plot so the tree matches the text #
# if there are too many categories
# Plotting results#
quartz()#
gomwuPlot(input,goAnnotations,goDivision,#
	absValue=-log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").#
	level1=0.4, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.05, # FDR cutoff to print in regular (not italic) font.#
	level3=0.01, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)#
# manually rescale the plot so the tree matches the text #
# if there are too many
# Plotting results#
quartz()#
gomwuPlot(input,goAnnotations,goDivision,#
	absValue=-log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").#
	level1=0.4, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.3, # FDR cutoff to print in regular (not italic) font.#
	level3=0.2, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)#
# manually rescale the plot so the tree matches the text #
# if there are too many categorie
# Plotting results#
quartz()#
gomwuPlot(input,goAnnotations,goDivision,#
	absValue=-log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").#
	level1=0.9, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.3, # FDR cutoff to print in regular (not italic) font.#
	level3=0.2, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)#
# manually rescale the plot so the tree matches the text #
# if there are too many
# First, press command-D on mac or ctrl-shift-H in Rstudio and navigate to the directory containing scripts and input files. Then edit, mark and execute the following bits of code, one after another.#
setwd("~/git_Repositories/reciprocal_transplant_methylation/go_mwu")#
#
# Edit these to match your data file names: #
input="origin_gbm_go_mwu_input.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).#
goAnnotations="adig_go_final.tsv" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.#
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml#
goDivision="CC" # either MF, or BP, or CC#
source("gomwu.functions.R")#
# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.#
gomwuStats(input, goDatabase, goAnnotations, goDivision,#
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already#
	largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes#
	smallest=5,   # a GO category should contain at least this many genes to be considered#
	clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.#
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. #
#	Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)#
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module #
)#
# do not continue if the printout shows that no
# Plotting results#
quartz()#
gomwuPlot(input,goAnnotations,goDivision,#
	absValue=-log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").#
	level1=0.9, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.3, # FDR cutoff to print in regular (not italic) font.#
	level3=0.2, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)#
# manually rescale the plot so the tree matches the text #
# if there are too many categories displayed, try make it more stringent with level1=0.05,level2=0.01,level3=0.001.
# Plotting results#
quartz()#
gomwuPlot(input,goAnnotations,goDivision,#
	absValue=-log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").#
	level1=0.4, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.3, # FDR cutoff to print in regular (not italic) font.#
	level3=0.2, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)#
# manually rescale the plot so the tree matches the text #
# if there are too many categor
gomwuPlot(input,goAnnotations,goDivision,#
	absValue=-log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").#
	level1=0.5, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.3, # FDR cutoff to print in regular (not italic) font.#
	level3=0.2, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)#
# manually rescale the plot so the tree matches the text #
# if there are too many ca
gomwuPlot(input,goAnnotations,goDivision,#
	absValue=-log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").#
	level1=0.6, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.3, # FDR cutoff to print in regular (not italic) font.#
	level3=0.2, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)#
# manually rescale the plot so the tree matches the text #
# if there are too many cate
gomwuPlot(input,goAnnotations,goDivision,#
	absValue=-log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").#
	level1=0.7, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.3, # FDR cutoff to print in regular (not italic) font.#
	level3=0.2, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)#
# manually rescale the plot so the tree matches the text #
# if there are too many categories displayed, try make it more stringent with level1=0.05,level2=0.01,level3=0.001.
goDivision="BP" # either MF, or BP, or CC
# Plotting results#
quartz()#
gomwuPlot(input,goAnnotations,goDivision,#
	absValue=-log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").#
	level1=0.7, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.3, # FDR cutoff to print in regular (not italic) font.#
	level3=0.2, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)#
# manually rescale the plot so the tree matches the text #
# if there are too many categories displayed, try make it more stringent with level1=0.05,level2=0.01,level3=0.001.
gomwuPlot(input,goAnnotations,goDivision,#
	absValue=-log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").#
	level1=0.9, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.3, # FDR cutoff to print in regular (not italic) font.#
	level3=0.2, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)#
# manually rescale the plot so the tree matches the text #
# if there are to
goDivision="BP" # either MF, or BP, or CC#
source("gomwu.functions.R")#
# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.#
gomwuStats(input, goDatabase, goAnnotations, goDivision,#
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already#
	largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes#
	smallest=5,   # a GO category should contain at least this many genes to be considered#
	clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.#
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. #
#	Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)#
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module #
)#
# do not continue if the printout shows that no GO terms pass 10% FDR.
to.run = 'position'
# Plotting results#
quartz()#
gomwuPlot(input,goAnnotations,goDivision,#
	absValue=-log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").#
	level1=0.9, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.3, # FDR cutoff to print in regular (not italic) font.#
	level3=0.2, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)#
# manually rescale the plot so the tree matches the text #
# if there are too many categories dis
#look at results file#
resName = paste(paste('MWU', goDivision, sep = "_"), input, sep = "_")#
res=read.table(resName, header = T)#
res=res[order(res$pval),]#
head(res, n=20)
head(res, n=30)
tail(res)
gomwuPlot(input,goAnnotations,goDivision,#
	absValue=-log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").#
	level1=0.7, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.3, # FDR cutoff to print in regular (not italic) font.#
	level3=0.2, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)#
# manually rescale the plot so the tree matches the text #
# if there are too many ca
goDivision="MF" # either MF, or BP, or CC
# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.#
gomwuStats(input, goDatabase, goAnnotations, goDivision,#
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already#
	largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes#
	smallest=5,   # a GO category should contain at least this many genes to be considered#
	clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.#
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. #
#	Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)#
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module #
)#
# do not continue if the printout sho
#look at results file#
resName = paste(paste('MWU', goDivision, sep = "_"), input, sep = "_")#
res=read.table(resName, header = T)#
res=res[order(res$pval),]#
head(res, n=30)
quartz()#
gomwuPlot(input,goAnnotations,goDivision,#
	absValue=-log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").#
	level1=0.5, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.#
	level2=0.3, # FDR cutoff to print in regular (not italic) font.#
	level3=0.2, # FDR cutoff to print in large bold font.#
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect#
	treeHeight=0.5, # height of the hierarchical clustering tree#
#	colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remar and change if needed#
)#
# manually rescale the plot so the tree matches the text #
# if there are too many categorie
